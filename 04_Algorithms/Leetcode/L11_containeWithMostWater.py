

# class Solution:
#     def maxArea(self, height) :
#     	heightDict = {}
#     	for k,val in enumerate(height):
#     		heightDict[k] = val
#     	heightDict = sorted(heightDict.items(),key = lambda item: item[1], reverse = True)
    	
#     	heightMax, maxIndex = heightDict[0][1], heightDict[0][0]
#     	x,xindex = heightDict[1][1],heightDict[1][0]
    	
#     	Index = [maxIndex,xindex]
#     	Index.sort()
#     	maxVal = x*abs(xindex-maxIndex)
#     	print(Index,maxVal)
    	
#     	count = 2
#     	while x*(len(height)-1)>maxVal:
#     		x,xindex = heightDict[count][1],heightDict[count][0]

#     		Index.append(xindex)
#     		Index.sort()
#     		print(Index)
#     		width = max(xindex-Index[0],Index[-1]-xindex)
#     		if x*width>maxVal:
#     			maxVal = x*width
#     		count += 1
#     	return maxVal


class Solution(object):
	"""Greedy algorithm can also solve: the greatest value is generated by the wider width 
and the bigger height which is saved while moving closer twoe edges."""
	def maxArea(self, height):
		start,end,maxVal = 0, len(height)-1, 0
		while start<end:
			StartEdge = height[start]
			EndEdge = height[end]
			if StartEdge>EndEdge:
				canVal = (end-start)*EndEdge
				end -= 1
			else:
				canVal = (end-start)*StartEdge
				start += 1
			if canVal>maxVal:
				maxVal = canVal
		return maxVal	

sol = Solution()
res = sol.maxArea(height = [1,8,6,2,5,4,8,3,7])
print(res)

